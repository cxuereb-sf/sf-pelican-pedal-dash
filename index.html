<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Pelican Pedal Dash â€” First Person</title>
<style>
  html, body {margin:0; background:#87CEEB; overflow:hidden; touch-action:none;}
  canvas {display:block;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = window.innerWidth, H = window.innerHeight;
canvas.width = W; canvas.height = H;

window.addEventListener('resize',()=>{
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W; canvas.height = H;
});

// Player state
let playerX = 0;  // horizontal position
let speed = 200;  // pixels per second forward speed
let steering = 0; // -1 left, 1 right

// Input handling
let keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

// Touch drag steering
let touchStartX = null;
canvas.addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
});
canvas.addEventListener('touchmove', e => {
  let dx = e.touches[0].clientX - touchStartX;
  playerX = Math.max(-W/3, Math.min(W/3, playerX + dx * 0.02));
  touchStartX = e.touches[0].clientX;
});
canvas.addEventListener('touchend', ()=>{ touchStartX = null; });

// Tilt steering
if(window.DeviceOrientationEvent){
  window.addEventListener('deviceorientation', e => {
    if(e.gamma !== null){
      playerX = Math.max(-W/3, Math.min(W/3, e.gamma * 5));
    }
  });
}

// Road segments
let segments = [];
let segmentLength = 40; // pixels
let roadLength = 2000;
for(let i=0;i<roadLength;i++){
  segments.push({curve: Math.sin(i/30)*0.5, y: i*segmentLength});
}

// Obstacles & landmarks
let obstacles = [];
let landmarks = [
  { name:"Coit Tower", dist:500, color:"#ccc" },
  { name:"Lombard St", dist:1000, color:"#a52a2a" },
  { name:"Cable Car", dist:1500, color:"#d2691e" }
];

function addObstacle(z){
  obstacles.push({x:(Math.random()-0.5)*W*0.4, z, size:40, color:"#ff0000"});
}
for(let i=200; i<roadLength*segmentLength; i+=300){
  addObstacle(i);
}

// Game loop
let position = 0;
let lastTime = performance.now();

function frame(now){
  let dt = (now - lastTime)/1000;
  lastTime = now;
  
  // Controls
  if(keys['ArrowLeft']) playerX -= 200*dt;
  if(keys['ArrowRight']) playerX += 200*dt;
  playerX = Math.max(-W/3, Math.min(W/3, playerX));
  
  position += speed * dt;
  if(position > roadLength*segmentLength) position -= roadLength*segmentLength;
  
  drawScene();
  requestAnimationFrame(frame);
}

function drawScene(){
  ctx.clearRect(0,0,W,H);
  
  // Sky
  ctx.fillStyle = "#87CEEB";
  ctx.fillRect(0,0,W,H*0.5);
  
  // Road
  let baseSegment = Math.floor(position/segmentLength);
  let camY = 1000;
  let camZ = position % segmentLength;
  let maxY = H;
  let x = 0;
  let dx = 0;
  
  for(let n=0; n<300; n++){
    let seg = segments[(baseSegment+n)%roadLength];
    let p1 = project(playerX - x, camY, n*segmentLength - camZ);
    let p2 = project(playerX - x - dx, camY, (n+1)*segmentLength - camZ);
    x += dx;
    dx += seg.curve;
    
    // draw segment
    ctx.fillStyle = (n%2===0) ? "#555" : "#777";
    ctx.beginPath();
    ctx.moveTo(p1.x-p1.w, p1.y);
    ctx.lineTo(p1.x+p1.w, p1.y);
    ctx.lineTo(p2.x+p2.w, p2.y);
    ctx.lineTo(p2.x-p2.w, p2.y);
    ctx.fill();
    
    // Side scenery (landmarks)
    landmarks.forEach(l=>{
      if(l.dist > position+n*segmentLength-50 && l.dist < position+n*segmentLength+50){
        ctx.fillStyle = l.color;
        ctx.fillRect(p2.x+200, p2.y-50, 50,50);
      }
    });
    
    if(p2.y >= maxY) break;
    maxY = p2.y;
  }
  
  // Obstacles
  obstacles.forEach(o=>{
    let relZ = o.z - position;
    if(relZ < 0) relZ += roadLength*segmentLength;
    if(relZ > 0 && relZ < 3000){
      let p = project(playerX+o.x, camY, relZ);
      let size = (W*0.05)/(relZ*0.002);
      ctx.fillStyle = o.color;
      ctx.fillRect(p.x-size/2, p.y-size, size, size);
    }
  });
  
  // Pelican handlebars
  ctx.fillStyle = "#333";
  ctx.fillRect(W/2-60, H-40, 120, 10); // bar
  ctx.fillRect(W/2-50, H-80, 20, 40); // left grip
  ctx.fillRect(W/2+30, H-80, 20, 40); // right grip
}

function project(x, y, z){
  let scale = 500 / z;
  return {
    x: W/2 + scale*x,
    y: H/2 - scale*y,
    w: scale * 200
  };
}

requestAnimationFrame(frame);
</script>
</body>
</html>
